/* 자손 결합자 */
.outer li{
  color: olivedrab;
}

/* 
  .outer 공백 li로 되어있을 때, outer 클래스의 자손 요소인 li 태그들에게 color : olivedrab를 적용하라는 의미가 된다. 그렇기 때문에  ol요소의 자손 요소인 li들은 여전히 검은색이다.

  java 와는 달리 자식 클래스 / 서브 클래스라는 표현을 쓰지 않는 이유는 자식 / 손주 / 증손주 ... 하위 항목들이 전부 다 css의 영향을 받기 때문이다.
  사과/포도/딸기/키위도 olivedrab이 된 점을 보면 알 수 있다.
*/

.outer > li {
  color: dodgerblue;
}

.outer > li li {
  text-decoration: underline;
}

/* 자손이 아니라 자식(1촌 자손)만 변경하고 싶다면 '>'가 포함된다. 
.outer > li > li 은 적용이 되지않는다.
.outer의 자식인 li의 자식은 ul이라는 점을 감안하면 적용이 불가능하다.

참고: 
.outer li {color: olivedrab;}을 없앴다고 가정하면, .outer > li {color: dodgerblue;}가 '자손' 까지 적용된다. 이상의 경우 서체나 텍스트 관련 등 일부 css 속성이 자식들에게 자동 상속되기 때문이다. 즉, 일촌 자식 결합자(>)라도 여기에 적용된 속성이 자동 상속을 지원하는 속성이라면 이를 덮어쓰는 다른 선택자와 속성을 지정하지 않으면 '자손'들도 해당 속성을 물려받는다.
*/

/* '뒤따르는' '모든' 동생들 결합자  */
.starter ~ li {
  font-style: italic;
}

/* 뒤따르는 '바로 다음' 동생 결합자 */
.starter + li {
  font-weight: bold;
}

/* 가상 클래스 */
/* 
  지금까지 특정 id나 특정 클래스를 선택해서 스타일을 지정했는데, 가상 클래스는 이와 달리 특정 상황을 가정하고 이름을 붙인다. 작성 방식은 콜론(:)을 사용한다.
*/

ol li:first-child, ol li:last-child {
  color: yellowgreen;
}

/* ~가 아닌 요소 가상 클래스 */

.outer > li:not(:last-child){
  text-decoration: line-through;
}

/* outer 클래스의 직계 자식인 li 태그 중에 마지막 요소가 아닌 것을 골라 line-through를 적용하라는 의미이다. 그렇다면 직계자식인 육류, 채소, 유제품, 과일 중에서 마지막 과일을 뺀 나머지 세개에만 취소선이 적용된다.
*/

ul:not(.outer) li {
  font-weight: bold;
}

/* ul 태그중 outer 클래스가 아닌 것을 골라서 그 자손인 li 요소에 bold를 적용하라는 의미. ul태그는 두 개로 중첩돼서 이루어졌기 때문에 들여 쓰기가 적용된 사과, 포도, 딸기, 키위가 포함된 ul은 class="outer"가 아니므로 bold체 적용 */

/* ~ 번째 요소 가상 클래스 */
/* odd / even을 ()내에 넣으면 결과값이 바뀐다. */
ol li:nth-child(3) {
  font-weight: bold;
  color: deeppink;
}

/* 가상 클래스 개념을 모르더라도 자주 쓰게 되는 예시 */
li:hover {
  font-weight: bold;
  color: blue;
}
/*  마우스 오버 기능을 지원하는 :hover의 경우 자주 쓰인다. 다만 김 3은 바뀌지 않는데 :hover보다 우선순위가 높기 때문이다(조건이 구체적이다.). */

